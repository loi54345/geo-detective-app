<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoGuessr Training App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        #pano {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        .gm-style-cc, .gm-fullscreen-control {
            display: none !important;
        }
        #map-container {
            position: absolute;
            bottom: 1.5rem;
            left: 1.5rem;
            width: 280px;
            height: 200px;
            z-index: 30;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            overflow: hidden;
            background-color: #e5e7eb;
            display: flex;
            flex-direction: column;
        }
        #map-container:hover, #map-container.enlarged {
            width: 65vw;
            height: 70vh;
            max-width: 900px;
            max-height: 700px;
        }
        #map-container.fullscreen {
             width: 100vw;
             height: 100vh;
             max-width: none;
             max-height: none;
             bottom: 0;
             left: 0;
             border-radius: 0;
             z-index: 50;
        }
        #map {
            width: 100%;
            height: 100%;
            flex-grow: 1;
            cursor: default !important;
        }
        #map-controls {
            display: none;
            position: absolute;
            bottom: 1.5rem;
            left: 1.5rem;
            right: 1.5rem;
            z-index: 60;
            justify-content: space-between;
            align-items: center;
        }
        #map-container:hover #map-controls, 
        #map-container.enlarged #map-controls,
        #map-container.fullscreen #map-controls {
            display: flex;
        }
        .map-btn, .time-toggle-btn, .map-region-btn {
            padding: 0.75rem 1.25rem;
            background-color: rgba(255,255,255,0.1);
            color: white;
            border-radius: 0.5rem;
            font-weight: 600;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(5px);
            cursor: pointer;
            transition: all 0.2s;
        }
        .map-btn:hover, .time-toggle-btn:hover, .map-region-btn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        #submit-guess-btn {
            background-color: #10b981;
            border-color: #059669;
        }
        #submit-guess-btn:hover {
            background-color: #059669;
        }
        #submit-guess-btn:disabled {
            background-color: #9ca3af;
            border-color: #6b7280;
            cursor: not-allowed;
        }
        #stats-page .time-toggle-btn, #stats-page .map-region-btn {
    background-color: #e5e7eb;
    color: #374151;
    padding: 0.5rem 1rem; /* Aggiungiamo un padding più piccolo */
}
       .time-toggle-btn.active, .map-region-btn.active {
    background-color: #3b82f6;
    color: white;
}
        .stat-tab {
             background-color: transparent;
             border-color: transparent;
             color: #6b7280;
             padding: 1rem;
             border-bottom-width: 2px;
        }
        .stat-tab.active {
            color: #4f46e5;
            border-color: #4f46e5;
        }
        #result-overlay {
            position: absolute;
            top: 1.5rem;
            left: 1.5rem;
            right: 1.5rem;
            width: auto;
            max-width: 400px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 1rem;
            z-index: 55;
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            border-radius: 0.75rem;
            backdrop-filter: blur(5px);
        }
        #game-controls {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 20;
            display: flex;
            gap: 0.75rem;
        }
        .ui-btn {
            padding: 0.75rem 1.5rem;
            background-color: rgba(0,0,0,0.6);
            color: white;
            border-radius: 0.5rem;
            font-weight: 600;
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(5px);
            cursor: pointer;
            transition: all 0.2s;
        }
        .ui-btn:hover {
            background-color: rgba(0,0,0,0.8);
            transform: translateY(-2px);
        }
        #stats-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f3f4f6;
            z-index: 100;
            overflow-y: auto;
            padding: 2rem;
            display: none;
        }
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 110;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            max-width: 500px;
        }
        .stat-card {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .stat-card h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #374151;
        }
        #fireworks-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            pointer-events: none;
            display: none;
        }
        .stat-tab-content { display: none; }
        .stat-tab-content.active { display: grid; }
        .sortable-th { cursor: pointer; }
        .sortable-th:hover { background-color: #e5e7eb; }
        .country-link { cursor: pointer; text-decoration: underline; color: #3b82f6; }
    #mute-toggle-btn.active {
    background-color: #ef4444; /* Un colore rosso per indicare che è attivo */
    color: white;
    border-color: #b91c1c;
}
#mute-toggle-btn.active:hover {
    background-color: #dc2626;
}
.modal-content .map-btn {
    background-color: #e5e7eb; /* Un grigio chiaro, come altri elementi UI */
    color: #374151; /* Un grigio scuro per il testo */
    border-color: #d1d5db;
}
.modal-content .map-btn:hover {
    background-color: #d1d5db; /* Un grigio leggermente più scuro al passaggio del mouse */
}
#settings-btn {
    position: absolute;
    top: 1.5rem;
    left: 1.5rem;
    z-index: 20;
    padding: 0.5rem; /* Riduciamo un po' il padding per un'icona */
}
.game-mode-btn {
    padding: 0.5rem 0.75rem;
    border-radius: 0.5rem;
    background-color: #f3f4f6;
    color: #4b5563;
    font-weight: 500;
    border: 1px solid #d1d5db;
    transition: all 0.2s;
}
.game-mode-btn:hover {
    background-color: #e5e7eb;
    border-color: #9ca3af;
}
.game-mode-btn.active {
    background-color: #4f46e5;
    color: white;
    border-color: #4338ca;
    font-weight: 600;
}
    </style>
</head>
<body class="bg-gray-800">
    <div id="pano"></div>
    <canvas id="fireworks-canvas"></canvas>
    
    <button id="settings-btn" class="ui-btn">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
</button>

    <div id="game-controls">
       <div id="streak-counter" class="ui-btn hidden" style="cursor: default;">Streak: <span class="ml-2 font-bold">0</span></div>
       <div id="distance-budget-counter" class="ui-btn hidden" style="cursor: default;">Budget: <span class="ml-2 font-bold">15000</span> km</div>
        <button id="stats-btn" class="ui-btn">Statistics</button>
    </div>
   <div id="settings-modal" class="modal-backdrop z-[120] hidden">
    <div class="modal-content">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold">Settings</h2>
            <button id="close-settings-modal" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
        </div>

        <div class="flex flex-col items-center gap-4 w-full">
            <p class="text-gray-600">Manage your application settings here.</p>
            
            <div class="w-full border-t border-gray-200 my-4"></div>

            <div class="w-full">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">Game Mode</h3>
                <div id="game-mode-container" class="grid grid-cols-2 sm:grid-cols-3 gap-2">
                    <button class="game-mode-btn" data-mode="World">World</button>
                    <button class="game-mode-btn" data-mode="WeightedWorld">Weighted World</button>
                    <button class="game-mode-btn" data-mode="DistanceChallenge" title="Complete as many rounds as you can before your 15,000km budget runs out!">Distance Challenge</button>
                    <button class="game-mode-btn" data-mode="Nemesis" title="Play only in your 5 worst performing countries!">Nemesis Training</button>
                    <button class="game-mode-btn" data-mode="Europe">Europe</button>
                    <button class="game-mode-btn" data-mode="Asia">Asia</button>
                    <button class="game-mode-btn" data-mode="North America">N. America</button>
                    <button class="game-mode-btn" data-mode="South America">S. America</button>
                    <button class="game-mode-btn" data-mode="Africa">Africa</button>
                    <button class="game-mode-btn" data-mode="Oceania">Oceania</button>
                </div>
                <button id="confirm-new-game-btn" class="map-btn hidden mt-4 bg-green-500 border-green-600 hover:bg-green-600 w-full">Confirm and Start New Game</button>
            </div>

            <div class="w-full border-t border-gray-200 my-4"></div>

            <button id="mute-toggle-btn" class="map-btn w-40">Mute All Sounds</button>
        </div>
    </div>
</div>

    <div id="map-container">
        <div id="map"></div>
        <div id="result-overlay">
            <h2 id="result-score" class="text-2xl font-bold"></h2>
            <p id="result-distance" class="text-lg"></p>
            <p id="result-country" class="text-md"></p>
        </div>
        <div id="map-controls">
            <button id="map-type-toggle" class="map-btn">Satellite</button>
            <button id="submit-guess-btn" class="map-btn" disabled>Submit Guess</button>
        </div>
    </div>
    
    <div id="loading-overlay" class="modal-backdrop z-[120]">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4">Finding a location...</h2>
            <p>This may take a moment. We're picking a country at random and searching for a good spot!</p>
        </div>
    </div>
    
    <div id="stats-page">
         <div class="flex justify-between items-center mb-6 max-w-7xl mx-auto">
            <h1 class="text-4xl font-bold text-gray-800">Your Performance Statistics</h1>
            <button id="close-stats-btn" class="ui-btn !bg-gray-700">Close</button>
        </div>
        <div class="max-w-7xl mx-auto">
            <div class="border-b border-gray-200 mb-4">
                <nav class="-mb-px flex space-x-8" aria-label="Tabs">
                    <button class="stat-tab" data-tab="core">Core Performance</button>
                    <button class="stat-tab" data-tab="confusion">Confusion Analysis</button>
                    <button class="stat-tab" data-tab="improvement">Improvement Over Time</button>
                    <button class="stat-tab" data-tab="additional">Additional Stats</button>
                </nav>
            </div>

            <div id="stats-content-container">
                 <div id="stats-placeholder" class="hidden text-center p-8">
                     <p class="text-lg text-gray-600">Play at least one round to see your detailed stats!</p>
                 </div>
                <!-- Core Performance Dashboard -->
                <div id="core-tab" class="stat-tab-content grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="stat-card md:col-span-3 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
    <div class="text-center p-4">
        <h3 class="text-lg font-medium text-gray-500">Overall Country Accuracy</h3>
        <p id="overall-accuracy" class="mt-1 text-5xl font-semibold text-indigo-600">0%</p>
        <p id="total-games" class="mt-2 text-sm text-gray-500"></p>
    </div>

    <div class="text-center p-4">
        <h3 class="text-lg font-medium text-gray-500">Longest Country Streak</h3>
        <p id="longest-streak-stat" class="mt-1 text-5xl font-semibold text-indigo-600">0</p>
        <p id="longest-streak-date" class="mt-2 text-sm text-gray-500"></p>
    </div>

    <div id="forte-list" class="p-4">
         <h3 class="text-lg font-medium text-green-600">My Forte (Top 5)</h3>
         <ul class="mt-2 space-y-2"></ul>
    </div>

    <div id="nemesis-list" class="p-4">
         <h3 class="text-lg font-medium text-red-600">My Nemesis (Bottom 5)</h3>
         <ul class="mt-2 space-y-2"></ul>
    </div>
</div>
                    <div class="stat-card md:col-span-3">
    <div class="flex justify-between items-start mb-4">
        <div>
            <h3>Performance World Map</h3>
            <p class="text-sm text-gray-500">Countries with 4 or more guesses are colored by accuracy. Hover for details.</p>
        </div>
        <div id="map-region-controls" class="flex flex-wrap gap-2 justify-end">
            <button class="map-region-btn active" data-region="world">World</button>
            <button class="map-region-btn" data-region="150">Europe</button>
            <button class="map-region-btn" data-region="142">Asia</button>
            <button class="map-region-btn" data-region="021">N. America</button>
            <button class="map-region-btn" data-region="005">S. America</button>
            <button class="map-region-btn" data-region="002">Africa</button>
            <button class="map-region-btn" data-region="009">Oceania</button>
        </div>
    </div>
    <div id="performance-map-chart" style="width: 100%; height: 500px;"></div>
</div>
                    <div class="stat-card md:col-span-3">
                        <h3>Per-Country Performance</h3>
                        <div class="overflow-y-auto max-h-[50vh]">
                            <table class="w-full text-left">
                                <thead class="bg-gray-50 sticky top-0">
                                    <tr>
                                        <th class="p-2 sortable-th" data-sort="name">Country</th>
                                        <th class="p-2 sortable-th" data-sort="seen">Times Seen</th>
                                        <th class="p-2 sortable-th" data-sort="correct">Correct Guesses</th>
                                        <th class="p-2 sortable-th" data-sort="accuracy">Accuracy</th>
                                    </tr>
                                </thead>
                                <tbody id="country-perf-table"></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Confusion Analysis Dashboard -->
                <div id="confusion-tab" class="stat-tab-content grid-cols-1 md:grid-cols-4 gap-6">
                     <div class="stat-card md:col-span-3">
                        <h3>Confusion Matrix</h3>
                        <div id="confusion-matrix-container" class="overflow-auto max-h-[60vh]"></div>
                     </div>
                     <div class="stat-card">
                        <h3>Top Confusion Pairs</h3>
                        <ul id="top-confusions-list" class="space-y-2"></ul>
                     </div>
                </div>

                <!-- Improvement Over Time Dashboard -->
                <div id="improvement-tab" class="stat-tab-content grid-cols-1 gap-6">
                    <div class="stat-card">
                        <h3>Overall Accuracy History</h3>
                        <div id="accuracy-time-toggle-container" class="flex justify-center gap-2 mb-4">
                             <button class="time-toggle-btn active" data-games="10">Last 10</button>
                             <button class="time-toggle-btn" data-games="100">Last 100</button>
                             <button class="time-toggle-btn" data-games="1000">Last 1000</button>
                             <button class="time-toggle-btn" data-games="all">All Time</button>
                        </div>
                        <canvas id="accuracy-history-chart"></canvas>
                    </div>
                    <div class="stat-card">
                        <h3>Nemesis Country Improvement</h3>
                         <div id="nemesis-charts-container" class="grid grid-cols-1 md:grid-cols-2 gap-6"></div>
                    </div>
                </div>
                 <!-- Additional Stats Dashboard -->
                 <div id="additional-tab" class="stat-tab-content grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="stat-card">
                        <h3>Distance Error Trend</h3>
                         <div id="distance-time-toggle-container" class="flex justify-center gap-2 mb-4">
                             <button class="time-toggle-btn active" data-games="20">Last 20</button>
                             <button class="time-toggle-btn" data-games="100">Last 100</button>
                             <button class="time-toggle-btn" data-games="1000">Last 1000</button>
                             <button class="time-toggle-btn" data-games="all">All Time</button>
                        </div>
                        <canvas id="distance-error-chart"></canvas>
                    </div>
                    <div class="stat-card">
                        <h3>Average Score by Continent</h3>
                        <canvas id="continent-performance-chart"></canvas>
                    </div>
                    <div class="stat-card md:col-span-2">
                        <h3>Average Score by Country (Grouped by Continent)</h3>
                        <div class="h-96">
                            <canvas id="country-by-continent-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
     <div id="country-breakdown-modal" class="modal-backdrop hidden">
        <div class="modal-content !max-w-3xl w-full bg-gray-100">
            <div class="flex justify-between items-center mb-4">
                 <h2 id="breakdown-title" class="text-2xl font-bold">Country Breakdown</h2>
                 <button id="close-breakdown-modal" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div class="grid grid-cols-2 gap-6">
                <div>
                    <h3 class="font-semibold text-lg mb-2">When it was <span class="country-name font-bold"></span>, I guessed...</h3>
                    <ul id="outgoing-confusions" class="space-y-1 text-left"></ul>
                </div>
                <div>
                     <h3 class="font-semibold text-lg mb-2">When I guessed <span class="country-name font-bold"></span>, it was actually...</h3>
                    <ul id="incoming-confusions" class="space-y-1 text-left"></ul>
                </div>
            </div>
        </div>
     </div>
     <div id="game-over-modal" class="modal-backdrop hidden z-[130]">
    <div id="game-over-modal" class="modal-backdrop hidden z-[130]">
        <div class="modal-content">
            <h2 class="text-3xl font-bold mb-2">Game Over!</h2>
            <p class="text-lg mb-4">Your streak has been broken.</p>
            <p class="text-xl mb-6">Final Streak: <strong id="final-streak" class="text-4xl text-indigo-600">0</strong></p>
            <button id="play-again-streak-btn" class="ui-btn !bg-indigo-600 hover:!bg-indigo-700">Play Again</button>
        </div>
    </div>

    <div id="distance-game-over-modal" class="modal-backdrop hidden z-[130]">
        <div class="modal-content">
            <h2 class="text-3xl font-bold mb-2">Budget Depleted!</h2>
            <p class="text-lg mb-4">You've run out of kilometers.</p>
            <p class="text-xl mb-6">Rounds Completed: <strong id="final-rounds-completed" class="text-4xl text-indigo-600">0</strong></p>
            <button id="play-again-distance-btn" class="ui-btn !bg-indigo-600 hover:!bg-indigo-700">Play Again</button>
        </div>
    </div>

    <script>
      
        // --- CONFIGURATION ---
        const GOOGLE_MAPS_API_KEY = "AIzaSyCpVIdowuqPNvmgb1pM6mFsE6ZbA4hdJQU";
        const STREET_VIEW_COUNTRIES = [
    { name: "Albania", code: "AL", continent: "Europe", area: 28748 },
    { name: "Andorra", code: "AD", continent: "Europe", area: 468 },
    { name: "Argentina", code: "AR", continent: "South America", area: 2780400 },
    { name: "Australia", code: "AU", continent: "Oceania", area: 7692024 },
    { name: "Austria", code: "AT", continent: "Europe", area: 83879 },
    { name: "Bangladesh", code: "BD", continent: "Asia", area: 147570 },
    { name: "Belgium", code: "BE", continent: "Europe", area: 30528 },
    { name: "Bermuda", code: "BM", continent: "North America", area: 54 },
    { name: "Bhutan", code: "BT", continent: "Asia", area: 38394 },
    { name: "Bolivia", code: "BO", continent: "South America", area: 1098581 },
    { name: "Botswana", code: "BW", continent: "Africa", area: 581730 },
    { name: "Brazil", code: "BR", continent: "South America", area: 8515767 },
    { name: "Bulgaria", code: "BG", continent: "Europe", area: 110994 },
    { name: "Cambodia", code: "KH", continent: "Asia", area: 181035 },
    { name: "Canada", code: "CA", continent: "North America", area: 9984670 },
    { name: "Chile", code: "CL", continent: "South America", area: 756102 },
    { name: "Colombia", code: "CO", continent: "South America", area: 1141748 },
    { name: "Croatia", code: "HR", continent: "Europe", area: 56594 },
    { name: "Curacao", code: "CW", continent: "North America", area: 444 },
    { name: "Czech Republic", code: "CZ", continent: "Europe", area: 78867 },
    { name: "Denmark", code: "DK", continent: "Europe", area: 43094 },
    { name: "Dominican Republic", code: "DO", continent: "North America", area: 48671 },
    { name: "Ecuador", code: "EC", continent: "South America", area: 283561 },
    { name: "Estonia", code: "EE", continent: "Europe", area: 45227 },
    { name: "Eswatini", code: "SZ", continent: "Africa", area: 17364 },
    { name: "Faroe Islands", code: "FO", continent: "Europe", area: 1399 },
    { name: "Finland", code: "FI", continent: "Europe", area: 338424 },
    { name: "France", code: "FR", continent: "Europe", area: 551695 },
    { name: "Germany", code: "DE", continent: "Europe", area: 357022 },
    { name: "Ghana", code: "GH", continent: "Africa", area: 238535 },
    { name: "Gibraltar", code: "GI", continent: "Europe", area: 6 },
    { name: "Greece", code: "GR", continent: "Europe", area: 131957 },
    { name: "Guatemala", code: "GT", continent: "North America", area: 108889 },
    { name: "Guam", code: "GU", continent: "Oceania", area: 544 },
    { name: "Hong Kong", code: "HK", continent: "Asia", area: 1104 },
    { name: "Hungary", code: "HU", continent: "Europe", area: 93028 },
    { name: "Iceland", code: "IS", continent: "Europe", area: 103000 },
    { name: "India", code: "IN", continent: "Asia", area: 3287263 },
    { name: "Indonesia", code: "ID", continent: "Asia", area: 1904569 },
    { name: "Ireland", code: "IE", continent: "Europe", area: 70273 },
    { name: "Isle of Man", code: "IM", continent: "Europe", area: 572 },
    { name: "Israel", code: "IL", continent: "Asia", area: 20770 },
    { name: "Italy", code: "IT", continent: "Europe", area: 301340 },
    { name: "Japan", code: "JP", continent: "Asia", area: 377975 },
    { name: "Jordan", code: "JO", continent: "Asia", area: 89342 },
    { name: "Kenya", code: "KE", continent: "Africa", area: 580367 },
    { name: "Kyrgyzstan", code: "KG", continent: "Asia", area: 199951 },
    { name: "Latvia", code: "LV", continent: "Europe", area: 64589 },
    { name: "Lesotho", code: "LS", continent: "Africa", area: 30355 },
    { name: "Lithuania", code: "LT", continent: "Europe", area: 65300 },
    { name: "Luxembourg", code: "LU", continent: "Europe", area: 2586 },
    { name: "Macau", code: "MO", continent: "Asia", area: 30 },
    { name: "Malaysia", code: "MY", continent: "Asia", area: 330803 },
    { name: "Malta", code: "MT", continent: "Europe", area: 316 },
    { name: "Mexico", code: "MX", continent: "North America", area: 1972550 },
    { name: "Monaco", code: "MC", continent: "Europe", area: 2 },
    { name: "Mongolia", code: "MN", continent: "Asia", area: 1564116 },
    { name: "Montenegro", code: "ME", continent: "Europe", area: 13812 },
    { name: "Netherlands", code: "NL", continent: "Europe", area: 41543 },
    { name: "New Zealand", code: "NZ", continent: "Oceania", area: 268021 },
    { name: "Nigeria", code: "NG", continent: "Africa", area: 923768 },
    { name: "North Macedonia", code: "MK", continent: "Europe", area: 25713 },
    { name: "Northern Mariana Islands", code: "MP", continent: "Oceania", area: 464 },
    { name: "Norway", code: "NO", continent: "Europe", area: 385207 },
    { name: "Peru", code: "PE", continent: "South America", area: 1285216 },
    { name: "Philippines", code: "PH", continent: "Asia", area: 300000 },
    { name: "Poland", code: "PL", continent: "Europe", area: 312696 },
    { name: "Portugal", code: "PT", continent: "Europe", area: 92212 },
    { name: "Puerto Rico", code: "PR", continent: "North America", area: 9104 },
    { name: "Qatar", code: "QA", continent: "Asia", area: 11586 },
    { name: "Reunion", code: "RE", continent: "Africa", area: 2511 },
    { name: "Romania", code: "RO", continent: "Europe", area: 238397 },
    { name: "Russia", code: "RU", continent: "Europe", area: 17098246 },
    { name: "San Marino", code: "SM", continent: "Europe", area: 61 },
    { name: "Senegal", code: "SN", continent: "Africa", area: 196722 },
    { name: "Serbia", code: "RS", continent: "Europe", area: 88361 },
    { name: "Singapore", code: "SG", continent: "Asia", area: 728 },
    { name: "Slovakia", code: "SK", continent: "Europe", area: 49035 },
    { name: "Slovenia", code: "SI", continent: "Europe", area: 20273 },
    { name: "South Africa", code: "ZA", continent: "Africa", area: 1221037 },
    { name: "South Korea", code: "KR", continent: "Asia", area: 100210 },
    { name: "Spain", code: "ES", continent: "Europe", area: 505990 },
    { name: "Sri Lanka", code: "LK", continent: "Asia", area: 65610 },
    { name: "Sweden", code: "SE", continent: "Europe", area: 450295 },
    { name: "Switzerland", code: "CH", continent: "Europe", area: 41285 },
    { name: "Taiwan", code: "TW", continent: "Asia", area: 36197 },
    { name: "Thailand", code: "TH", continent: "Asia", area: 513120 },
    { name: "Tunisia", code: "TN", continent: "Africa", area: 163610 },
    { name: "Turkey", code: "TR", continent: "Asia", area: 783562 },
    { name: "Uganda", code: "UG", continent: "Africa", area: 241551 },
    { name: "Ukraine", code: "UA", continent: "Europe", area: 603628 },
    { name: "United Arab Emirates", code: "AE", continent: "Asia", area: 83600 },
    { name: "United Kingdom", code: "GB", continent: "Europe", area: 243610 },
    { name: "United States", code: "US", continent: "North America", area: 9833520 },
    { name: "Uruguay", code: "UY", continent: "South America", area: 176215 },
    { name: "US Virgin Islands", code: "VI", continent: "North America", area: 346 }
];
        const countryNameMap = {
            "Türkiye": "Turkey"
        };

        // --- GLOBAL VARIABLES ---
let panorama, map, geocoder, streetViewService, uiSounds = {};
let actualLocation = null;
let actualCountryData = { name: null, code: null, bounds: null };
let guessMarker = null;
let actualMarker = null;
let guessLine = null;
let charts = {};
let currentSort = { column: 'name', order: 'asc' };
let isMuted = false;
let isGeoChartLibLoaded = false;
let activeGameMode = 'World';
let tempSelectedMode = 'World';

// NUOVO OGGETTO PER LO STATO DEL GIOCO
let gameState = {
    roundActive: false,
    currentStreak: 0,
    longestStreak: 0,
    distanceBudget: 15000, // Budget iniziale per la modalità Sfida a Distanza
    roundsCompleted: 0,
    score: 0
};

        // --- DOM ELEMENTS ---
        const submitBtn = document.getElementById('submit-guess-btn');
        const mapContainer = document.getElementById('map-container');
        const mapTypeToggle = document.getElementById('map-type-toggle');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsModal = document.getElementById('close-settings-modal');
        const muteToggleBtn = document.getElementById('mute-toggle-btn');

        // --- INITIALIZATION ---
        function initMap() {
        // Carica la libreria di Google Charts e il pacchetto GeoChart
    google.charts.load('current', { 'packages': ['geochart'] });
    google.charts.setOnLoadCallback(() => {
        isGeoChartLibLoaded = true;
        // Prova a disegnare la mappa se le statistiche sono già visibili
        if (document.getElementById('stats-page').style.display === 'block') {
            renderAllCharts(getGameStats());
        }
    });

            streetViewService = new google.maps.StreetViewService();
            geocoder = new google.maps.Geocoder();
            
            panorama = new google.maps.StreetViewPanorama(document.getElementById('pano'), {
                addressControl: false, showRoadLabels: false, zoomControl: true,
                panControl: true, linksControl: true, enableCloseButton: false, fullscreenControl: false,
                pov: { heading: 0, pitch: 0 }, zoom: 0, motionTracking: false, motionTrackingControl: false,
                compassControl: true, compassControlOptions: { position: google.maps.ControlPosition.RIGHT_BOTTOM }
            });

            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 20, lng: 0 }, zoom: 2, mapTypeId: 'terrain',
                disableDefaultUI: true, zoomControl: true, mapTypeControl: false, streetViewControl: false,
                scrollwheel: true, gestureHandling: 'auto', draggableCursor: 'default', draggingCursor: 'move'
            });

            const markerIcon = {
                path: 'M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z',
                fillColor: '#3b82f6', fillOpacity: 1, strokeWeight: 1, strokeColor: '#ffffff',
                rotation: 0, scale: 1.5, anchor: new google.maps.Point(12, 22)
            };
            
            guessMarker = new google.maps.Marker({ map: map, draggable: true, icon: markerIcon });
            
            setupAudio();
            setupEventListeners();
            loadSettings()
            startNewRound();
        }

       function setupEventListeners() {
    map.addListener('click', (e) => {
        if (gameState.roundActive) {
            uiSounds.pinDrop.triggerAttackRelease("G1", "1n");
            guessMarker.setPosition(e.latLng);
            guessMarker.setVisible(true);
            submitBtn.disabled = false;
        }
    });

    submitBtn.addEventListener('click', handleActionClick);
    mapTypeToggle.addEventListener('click', () => {
        uiSounds.click.triggerAttackRelease("C6", "8n");
        toggleMapType();
    });

    // --- LOGICA PAGINA STATISTICHE (RI-AGGIUNTA) ---
    document.getElementById('stats-btn').addEventListener('click', showStatsPage);
    
    document.getElementById('close-stats-btn').addEventListener('click', () => {
         uiSounds.click.triggerAttackRelease("C6", "8n");
         document.getElementById('stats-page').style.display = 'none';
    });
    
    document.querySelectorAll('.stat-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
            uiSounds.click.triggerAttackRelease("C6", "8n");
            document.querySelectorAll('.stat-tab').forEach(t => t.classList.remove('active'));
            e.target.classList.add('active');
            document.querySelectorAll('.stat-tab-content').forEach(c => c.classList.remove('active'));
            const tabContent = document.getElementById(e.target.dataset.tab + '-tab');
            if(tabContent) tabContent.classList.add('active');
            renderAllCharts(getGameStats());
        });
    });

    document.getElementById('close-breakdown-modal').addEventListener('click', () => {
        document.getElementById('country-breakdown-modal').classList.add('hidden');
    });

    document.querySelectorAll('.sortable-th').forEach(th => {
        th.addEventListener('click', (e) => {
            const sortBy = e.target.dataset.sort;
            if (currentSort.column === sortBy) {
                currentSort.order = currentSort.order === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = sortBy;
                currentSort.order = 'asc';
            }
            renderPerCountryTable(getGameStats(), sortBy, currentSort.order);
        });
    });
    
     document.getElementById('accuracy-time-toggle-container')?.addEventListener('click', (e) => {
         if (e.target.classList.contains('time-toggle-btn')) {
            uiSounds.click.triggerAttackRelease("C6", "8n");
            document.querySelectorAll('#accuracy-time-toggle-container .time-toggle-btn').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
            renderAccuracyHistory(getGameStats());
         }
    });
    document.getElementById('distance-time-toggle-container')?.addEventListener('click', (e) => {
         if (e.target.classList.contains('time-toggle-btn')) {
            uiSounds.click.triggerAttackRelease("C6", "8n");
            document.querySelectorAll('#distance-time-toggle-container .time-toggle-btn').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
            renderDistanceErrorTrend(getGameStats());
         }
    });

    // --- LOGICA FINESTRA IMPOSTAZIONI ---
    const confirmBtn = document.getElementById('confirm-new-game-btn');

    settingsBtn.addEventListener('click', () => {
        uiSounds.click.triggerAttackRelease("C6", "8n");
        tempSelectedMode = activeGameMode; 
        updateGameModeButtonsUI();
        confirmBtn.classList.add('hidden');
        settingsModal.classList.remove('hidden');
    });

    closeSettingsModal.addEventListener('click', () => {
        uiSounds.click.triggerAttackRelease("C6", "8n");
        settingsModal.classList.add('hidden');
    });

    document.querySelectorAll('.game-mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            tempSelectedMode = btn.dataset.mode;
            updateGameModeButtonsUI();
            if (tempSelectedMode !== activeGameMode) {
                confirmBtn.classList.remove('hidden');
            } else {
                confirmBtn.classList.add('hidden');
            }
            uiSounds.click.triggerAttackRelease("E5", "8n");
        });
    });

    // Replace the existing confirmBtn listener with this
    confirmBtn.addEventListener('click', () => {
        activeGameMode = tempSelectedMode;
        localStorage.setItem('geoGameMode', activeGameMode);
        settingsModal.classList.add('hidden');
        uiSounds.click.triggerAttackRelease("G5", "8n");

        // RESET logic for the new mode
        if (activeGameMode === 'DistanceChallenge') {
            gameState.distanceBudget = 15000;
            gameState.roundsCompleted = 0;
        }

        startNewRound();
    });

    muteToggleBtn.addEventListener('click', () => {
        isMuted = !isMuted;
        Tone.Destination.mute = isMuted;
        localStorage.setItem('geoMuteState', isMuted);
        updateMuteButtonUI();
        if (!isMuted) {
           uiSounds.click.triggerAttackRelease("C6", "8n");
        
        }
    });
    // Aggiungi questo nuovo listener per i pulsanti della regione della mappa
document.getElementById('map-region-controls')?.addEventListener('click', (e) => {
     if (e.target.classList.contains('map-region-btn')) {
        uiSounds.click.triggerAttackRelease("C6", "8n");

        // Rimuovi la classe 'active' da tutti i pulsanti di regione
        document.querySelectorAll('#map-region-controls .map-region-btn').forEach(btn => btn.classList.remove('active'));

        // Aggiungi la classe 'active' al pulsante cliccato
        e.target.classList.add('active');

        // Ottieni la regione dal data-attribute del pulsante
        const newRegion = e.target.dataset.region;

        // Ridisegna la mappa con la nuova regione
        renderPerformanceMap(getGameStats(), newRegion);
     }
     // Add this to the end of the setupEventListeners function
    document.getElementById('play-again-distance-btn').addEventListener('click', () => {
        document.getElementById('distance-game-over-modal').classList.add('hidden');
        // Reset the state and start a new game
        gameState.distanceBudget = 15000;
        gameState.roundsCompleted = 0;
        startNewRound();
    });
});
// Aggiungi alla fine della funzione setupEventListeners
document.getElementById('play-again-streak-btn').addEventListener('click', () => {
    document.getElementById('game-over-modal').classList.add('hidden');
    gameState.currentStreak = 0; // Azzera la serie
    startNewRound();
});
}
    
    function updateGameModeButtonsUI() {
        document.querySelectorAll('.game-mode-btn').forEach(btn => {
            // Usa la selezione temporanea per l'aggiornamento visivo
            if (btn.dataset.mode === tempSelectedMode) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }

    function updateMuteButtonUI() {
        if (isMuted) {
            muteToggleBtn.classList.add('active');
            muteToggleBtn.textContent = 'Unmute';
        } else {
            muteToggleBtn.classList.remove('active');
            muteToggleBtn.textContent = 'Mute All Sounds';
        }
    }

    function loadSettings() {
        // Carica la modalità di gioco salvata
        const savedMode = localStorage.getItem('geoGameMode');
        if (savedMode) {
            activeGameMode = savedMode;
            tempSelectedMode = savedMode;
        }

        // Carica lo stato del muto salvato
        const savedMute = localStorage.getItem('geoMuteState');
        isMuted = savedMute === 'true';
        Tone.Destination.mute = isMuted;
        
         const savedLongestStreak = localStorage.getItem('geoLongestStreak');
    if (savedLongestStreak) {
        gameState.longestStreak = parseInt(savedLongestStreak, 10);
    }

        // Aggiorna la UI all'avvio
        updateMuteButtonUI();
        updateGameModeButtonsUI();
    }
    
   function renderPerformanceMap(stats, region = 'world') {
    if (!isGeoChartLibLoaded) {
        console.log("Libreria GeoChart non ancora caricata.");
        return;
    }

    const chartDiv = document.getElementById('performance-map-chart');
    if (!chartDiv) return;

    // 1. Calcola le statistiche di accuratezza per paese (invariato)
    const countryData = stats.reduce((acc, game) => {
        const name = normalizeCountryName(game.actualCountry.name);
        if (!acc[name]) {
            acc[name] = { seen: 0, correct: 0 };
        }
        acc[name].seen++;
        if (normalizeCountryName(game.actualCountry.name) === normalizeCountryName(game.guessedCountry.name)) {
            acc[name].correct++;
        }
        return acc;
    }, {});

    // 2. Formatta i dati per Google Charts (invariato)
    const chartData = [['Country', 'Accuracy (%)']];
    for (const countryName in countryData) {
        const data = countryData[countryName];
        if (data.seen >= 4) {
            const accuracy = (data.correct / data.seen) * 100;
            chartData.push([countryName, accuracy]);
        }
    }

    if (chartData.length <= 1) {
        chartDiv.innerHTML = '<p class="text-center text-gray-500">Gioca di più per vedere i tuoi dati sulla mappa!</p>';
        return;
    }

    const dataTable = google.visualization.arrayToDataTable(chartData);

    // 3. Definisci le opzioni del grafico USANDO IL NUOVO PARAMETRO 'region'
    const options = {
        colorAxis: {
            colors: ['#e7711b', '#fefde2', '#56b870'], // Arancione -> Giallo -> Verde
            minValue: 0,
            maxValue: 100
        },
        backgroundColor: '#f9fafb', 
        datalessRegionColor: '#e5e7eb',
        defaultColor: '#e5e7eb',
        // MODIFICA CHIAVE: Usa direttamente il parametro 'region' fornito alla funzione.
        // Non dipende più da activeGameMode.
        region: region
    };

    // 4. Disegna il grafico (invariato)
    const chart = new google.visualization.GeoChart(chartDiv);
    chart.draw(dataTable, options);
}
        
        
        
        function handleActionClick() {
    // --- BLOCCO DI DIAGNOSI ---
    console.log("Pulsante cliccato!");
    console.log("Valore di gameState.roundActive al momento del click:", gameState.roundActive);
    // --- FINE DIAGNOSI ---

    uiSounds.click.triggerAttackRelease("C6", "8n");
    if (gameState.roundActive) {
        console.log("Condizione IF è VERA. Chiamo submitGuess() di nuovo.");
        submitGuess();
    } else {
        console.log("Condizione IF è FALSA. Chiamo startNewRound() come previsto.");
        startNewRound();
    }
}
        
        function setupAudio() {
            const reverb = new Tone.Reverb(1.5).toDestination();
            reverb.wet.value = 0.3;
            
            uiSounds.click = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 4, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
            uiSounds.click.volume.value = -18;

            uiSounds.pinDrop = new Tone.MembraneSynth({ pitchDecay: 0.1, octaves: 2, envelope: { attack: 0.01, decay: 0.8, sustain: 0 }, oscillator: { type: 'sine' } }).connect(reverb);
            uiSounds.pinDrop.volume.value = -10;

            uiSounds.whistle = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.05, decay: 0.5, sustain: 0, release: 0.5 } }).connect(reverb);
            uiSounds.whistle.volume.value = -10;
            uiSounds.explosion = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0 } }).connect(reverb);
            uiSounds.explosion.volume.value = -5;
            uiSounds.choir = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'fatsawtooth', count: 4, spread: 60 },
                envelope: { attack: 0.8, decay: 0.2, sustain: 0.8, release: 2 }
            }).connect(reverb);
            uiSounds.choir.volume.value = -15;
            uiSounds.superVictory = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'fatsquare', count: 5, spread: 30 },
                envelope: { attack: 0.1, decay: 2, sustain: 0.5, release: 2 }
            }).connect(reverb);
            uiSounds.superVictory.volume.value = -9;

            const ambientFilter = new Tone.AutoFilter("2m").toDestination().start();
            const ambientPad = new Tone.PolySynth(Tone.Synth, {
                 oscillator: { type: 'fatsine' },
                 envelope: { attack: 4, decay: 0.5, sustain: 1, release: 4 }
            }).connect(ambientFilter);
            ambientPad.volume.value = -28;
            
            new Tone.Loop(time => {
                ambientPad.triggerAttackRelease(['C2', 'G2', 'C3'], '4m', time);
            }, "2m").start(0);

            document.body.addEventListener('click', async () => {
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                    Tone.Transport.start();
                }
            }, { once: true });
        }
        
        function playVictorySound(isSuper) {
            const now = Tone.now();
            uiSounds.whistle.triggerAttack(now);
            uiSounds.whistle.frequency.rampTo('C6', 0.5, now);
            uiSounds.whistle.triggerRelease(now + 0.5);
            uiSounds.explosion.triggerAttack(now + 0.5);
            uiSounds.choir.triggerAttackRelease(['C4', 'G4', 'C5', 'E5'], '4s', now + 0.1);

            if (isSuper) {
                 uiSounds.superVictory.triggerAttackRelease(['F4', 'A4', 'C5', 'F5'], '3s', now + 0.2);
            }
        }

        function toggleMapType() {
            const currentType = map.getMapTypeId();
            if (currentType === 'terrain') {
                map.setMapTypeId('satellite');
                mapTypeToggle.textContent = 'Terrain';
            } else {
                map.setMapTypeId('terrain');
                mapTypeToggle.textContent = 'Satellite';
            }
        }

        // --- GAME LOGIC ---
        // Replace the existing startNewRound function with this
    function startNewRound() {
        submitBtn.classList.remove('hidden');
        document.getElementById('fireworks-canvas').style.display = 'none';

        // --- UI Management for Different Modes ---
        const streakCounter = document.getElementById('streak-counter');
        const budgetCounter = document.getElementById('distance-budget-counter');
        
        // Always show and update the streak counter
        streakCounter.classList.remove('hidden');
        streakCounter.querySelector('span').textContent = gameState.currentStreak;

        // Logic for Distance Challenge
        if (activeGameMode === 'DistanceChallenge') {
            gameState.roundsCompleted++; // Increment round counter
            budgetCounter.classList.remove('hidden');
            budgetCounter.querySelector('span').textContent = `${Math.round(gameState.distanceBudget)} km`;
        } else {
            budgetCounter.classList.add('hidden'); // Hide if not in this mode
        }

        // --- Rest of the function (Resetting the UI) ---
        document.getElementById('confirm-new-game-btn').classList.add('hidden');
        document.getElementById('loading-overlay').style.display = 'flex';
        document.getElementById('result-overlay').style.display = 'none';
        mapContainer.classList.remove('fullscreen', 'enlarged');
        
        submitBtn.textContent = 'Submit Guess';
        submitBtn.disabled = true;
        map.setCenter({ lat: 20, lng: 0 });
        map.setZoom(2);

        if (guessMarker) guessMarker.setVisible(false);
        if (actualMarker) actualMarker.setVisible(false);
        if (guessLine) guessLine.setMap(null);
        
        panorama.setOptions({ 
            linksControl: true, panControl: true, visible: false, 
            pov: {heading: Math.random() * 360, pitch: 0}, 
            zoom: 0 
        });

        findRandomStreetViewLocation();
    }
    // --- FINE BLOCCO DI DIAGNOSI ---

    // Il resto della funzione rimane invariato
    document.getElementById('confirm-new-game-btn').classList.add('hidden');
    document.getElementById('loading-overlay').style.display = 'flex';
    document.getElementById('result-overlay').style.display = 'none';
    mapContainer.classList.remove('fullscreen', 'enlarged');
    
    submitBtn.textContent = 'Submit Guess';
    submitBtn.disabled = true;

    map.setCenter({ lat: 20, lng: 0 });
    map.setZoom(2);

    if (guessMarker) guessMarker.setVisible(false);
    if (actualMarker) actualMarker.setVisible(false);
    if (guessLine) guessLine.setMap(null);
    
    panorama.setOptions({ 
        linksControl: true, panControl: true, visible: false, 
        pov: {heading: Math.random() * 360, pitch: 0}, 
        zoom: 0 
    });

    findRandomStreetViewLocation();
}

// Sostituisci la vecchia funzione submitGuess con questa nuova versione
// Replace the existing submitGuess function with this
    async function submitGuess() {
        if (!guessMarker.getPosition() || !gameState.roundActive) return;

        gameState.roundActive = false;
        submitBtn.disabled = true;
        const guessedLocation = guessMarker.getPosition();
        let guessedCountry = { name: 'Unknown', code: 'N/A' };
        try {
            const { results } = await geocoder.geocode({ location: guessedLocation });
            const address = results.find(r => r.types.includes('country'));
            if (address) {
                const countryComponent = address.address_components.find(c => c.types.includes('country'));
                if (countryComponent) {
                    guessedCountry = { name: normalizeCountryName(countryComponent.long_name), code: countryComponent.short_name };
                }
            }
        } catch (e) { console.error("Geocoding guess failed", e); }

        const distance = google.maps.geometry.spherical.computeDistanceBetween(actualLocation, guessedLocation);
        const isCountryCorrect = guessedCountry.code === actualCountryData.code;
        const proximityBonus = 2500 * Math.exp(-distance / 2000000);
        let score = isCountryCorrect ? 2500 + proximityBonus : proximityBonus * 0.8;
        score = Math.round(score);
        gameState.score = score;

        // Universal Streak Logic (active in all modes)
        if (isCountryCorrect) {
            gameState.currentStreak++;
            if (gameState.currentStreak > gameState.longestStreak) {
                gameState.longestStreak = gameState.currentStreak;
                localStorage.setItem('geoLongestStreak', gameState.longestStreak);
            }
        } else {
            gameState.currentStreak = 0;
        }

        // Save stats for every round
        saveGameStats({ score, distance: distance / 1000, actualCountry: actualCountryData, guessedCountry, timestamp: new Date().toISOString() });
        
        // --- DISTANCE CHALLENGE - SPECIFIC LOGIC ---
        if (activeGameMode === 'DistanceChallenge') {
            gameState.distanceBudget -= (distance / 1000); // Subtract distance in km

            if (gameState.distanceBudget <= 0) {
                // GAME OVER
                gameState.distanceBudget = 0; // Prevent negative display
                showRoundResult(score, distance, isCountryCorrect, guessedCountry.name); // Show final round result
                document.getElementById('final-rounds-completed').textContent = gameState.roundsCompleted;
                document.getElementById('distance-game-over-modal').classList.remove('hidden');
                submitBtn.classList.add('hidden'); // Hide "Next Round" button
                return; // Stop the function here to end the game
            }
        }

        // If not game over, show round result and prepare for the next round
        showRoundResult(score, distance, isCountryCorrect, guessedCountry.name);
        submitBtn.textContent = 'Next Round';
        submitBtn.disabled = false;
        
        if (isCountryCorrect && distance <= 5000) {
            triggerCelebration(true);
        } else if (isCountryCorrect && distance <= 200000) {
            triggerCelebration(false);
        }
    }

        function normalizeCountryName(name) {
            return countryNameMap[name] || name;
        }
        
        async function isPanoOnRoad(latLng) {
            try {
                const roadEndpoint = `https://roads.googleapis.com/v1/snapToRoads?path=${latLng.lat()},${latLng.lng()}&key=${GOOGLE_MAPS_API_KEY}`;
                const roadResponse = await fetch(roadEndpoint);
                if (!roadResponse.ok) {
                    console.error("Roads API request failed:", roadResponse.status, roadResponse.statusText);
                    return false;
                }
                const roadData = await roadResponse.json();
                return roadData.snappedPoints && roadData.snappedPoints.length > 0;
            } catch (error) {
                console.error("Error calling Roads API:", error);
                return false;
            }
        }

   async function findRandomStreetViewLocation() {
    let randomCountry;

    // --- INIZIO LOGICA DI SELEZIONE CORRETTA ---
    if (activeGameMode === 'World' || activeGameMode === 'CountryStreak' || activeGameMode === 'DistanceChallenge') {
        // Per queste modalità, scegliamo un paese a caso da tutta la lista.
        const countriesToSearch = STREET_VIEW_COUNTRIES;
        randomCountry = countriesToSearch[Math.floor(Math.random() * countriesToSearch.length)];
    } 
    else if (activeGameMode === 'WeightedWorld') {
        // Modalità ponderata per area
        const countriesToSearch = STREET_VIEW_COUNTRIES;
        const totalArea = countriesToSearch.reduce((sum, country) => sum + (country.area || 0), 0);
        let randomWeight = Math.random() * totalArea;
        for (const country of countriesToSearch) {
            randomWeight -= (country.area || 0);
            if (randomWeight <= 0) {
                randomCountry = country;
                break;
            }
        }
    } 
    else if (activeGameMode === 'Nemesis') {
        // Modalità Allenamento Nemesis
        console.log("Modalità Nemesis attivata. Calcolo i paesi peggiori...");
        const nemesisCountries = getNemesisCountries();

        if (nemesisCountries.length === 0) {
            console.log("Nessun paese 'Nemesis' trovato (serve più storico). Avvio una partita 'World' normale.");
            alert("You don't have enough data for Nemesis mode yet! A 'World' round will be started. Play more to unlock it!");
            const countriesToSearch = STREET_VIEW_COUNTRIES;
            randomCountry = countriesToSearch[Math.floor(Math.random() * countriesToSearch.length)];
        } else {
            console.log("Paesi Nemesis trovati:", nemesisCountries.map(c => c.name));
            randomCountry = nemesisCountries[Math.floor(Math.random() * nemesisCountries.length)];
        }
    } 
    else {
        // Se non è nessuna delle precedenti, ALLORA è una selezione per continente
        const countriesToSearch = STREET_VIEW_COUNTRIES.filter(c => c.continent === activeGameMode);
        if (!countriesToSearch || countriesToSearch.length === 0) {
            alert("Nessun paese disponibile per la modalità di gioco selezionata!");
            return;
        }
        randomCountry = countriesToSearch[Math.floor(Math.random() * countriesToSearch.length)];
    }
    // --- FINE LOGICA DI SELEZIONE ---

    // Il resto della funzione rimane invariato...
    const countryCode = randomCountry.code;
    const countryName = randomCountry.name;
    const bucketBaseUrl = 'https://storage.googleapis.com/geo-detective-data-tuonome-123';
    const boundariesUrl = `${bucketBaseUrl}/${countryCode}.json`;

    console.log(`Modalità: ${activeGameMode}. Paese scelto: ${countryName}. Recupero confini da: ${boundariesUrl}`);
    document.getElementById('loading-overlay').style.display = 'flex';
    
    try {
        const response = await fetch(boundariesUrl);
        if (!response.ok) throw new Error(`File non trovato per ${countryName} (${countryCode}.json).`);
        
        const countryGeoJSON = await response.json();
        if (!countryGeoJSON || !countryGeoJSON.features || countryGeoJSON.features.length === 0) throw new Error(`Dati GeoJSON non validi o vuoti per ${countryName}.`);
        
        const countryFeature = countryGeoJSON.features.find(f => f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));
        if (!countryFeature) throw new Error(`Nessuna geometria di tipo Polygon o MultiPolygon trovata per ${countryName}.`);

        console.log("Confini caricati e validati. Inizio ricerca punto valido...");
        let randomLatLng;
        let pointFound = false;
        const bbox = turf.bbox(countryFeature.geometry);
        let findPointAttempts = 0;
        while (!pointFound && findPointAttempts < 500) {
            const randomPtArray = turf.randomPosition(bbox); 
            if (turf.booleanPointInPolygon(randomPtArray, countryFeature.geometry)) {
                randomLatLng = new google.maps.LatLng(randomPtArray[1], randomPtArray[0]);
                pointFound = true;
            }
            findPointAttempts++;
        }

        if (!pointFound) throw new Error(`Impossibile trovare un punto valido nei confini di ${countryName} dopo ${findPointAttempts} tentativi.`);
        
        console.log("Punto valido trovato all'interno dei confini!");
        let panoramaFound = false;
        let panoramaAttempt = 0;
        while(!panoramaFound && panoramaAttempt < 5) {
             console.log(`Ricerca Street View per ${countryName}, tentativo ${panoramaAttempt + 1}...`);
             const { data } = await streetViewService.getPanorama({
                location: randomLatLng,
                radius: 50000 + (panoramaAttempt * 50000),
                source: 'outdoor'
             });
             if (data?.location?.pano) {
                console.log("Panorama trovato!");
                await setupAndFinalizeRound(data, randomCountry, null);
                panoramaFound = true;
                return; 
             }
             panoramaAttempt++;
        }
        throw new Error(`Nessun panorama trovato vicino al punto generato per ${countryName}.`);
    } catch (error) {
        console.error("ERRORE GESTITO:", error.message, "Riprovo con un nuovo paese.");
        startNewRound();
    }
}
/**
 * Analizza le statistiche di gioco e restituisce i paesi con la peggior performance.
 * @param {number} count - Il numero di paesi nemesis da restituire.
 * @returns {Array} - Un array di oggetti paese.
 */
function getNemesisCountries(count = 5) {
    const stats = getGameStats();
    // Richiediamo un minimo di 20 partite per avere dati significativi
    if (stats.length < 20) return [];

    const countryData = stats.reduce((acc, game) => {
        const code = game.actualCountry.code;
        if (!code) return acc; // Salta i round con dati corrotti

        // Inizializza il paese se non esiste
        if (!acc[code]) {
            // Troviamo i dati completi del paese dalla nostra lista principale
            const countryInfo = STREET_VIEW_COUNTRIES.find(c => c.code === code);
            if (!countryInfo) return acc; // Salta se il paese non è nella nostra lista
            acc[code] = { ...countryInfo, seen: 0, correct: 0 };
        }

        acc[code].seen++;
        if (game.actualCountry.code === game.guessedCountry.code) {
            acc[code].correct++;
        }
        return acc;
    }, {});

    const tableData = Object.values(countryData).map(d => ({
        ...d,
        accuracy: d.seen > 0 ? (d.correct / d.seen) * 100 : 0
    }));

    // Filtriamo per paesi visti almeno 3 volte, per evitare che un paese visto una sola
    // volta e sbagliato diventi subito un nemesis.
    const eligibleCountries = tableData.filter(d => d.seen >= 3);

    // Ordiniamo per accuratezza (dal peggiore al migliore) e poi per numero di volte viste
    eligibleCountries.sort((a, b) => {
        if (a.accuracy < b.accuracy) return -1;
        if (a.accuracy > b.accuracy) return 1;
        if (a.seen > b.seen) return -1; // A parità di accuratezza, diamo priorità a quello visto più volte
        if (a.seen < b.seen) return 1;
        return 0;
    });

    // Restituiamo i primi 'count' paesi
    return eligibleCountries.slice(0, count);
}

// Assicurati di avere anche questa funzione di supporto nel tuo codice,
// incollala subito dopo la funzione precedente se non ce l'hai già.
async function setupAndFinalizeRound(data, country, bounds) {
    actualLocation = data.location.latLng;
    addUsedPanoId(data.location.pano);

    const actualGeoResult = await geocoder.geocode({ location: actualLocation });
    const address = actualGeoResult.results.find(r => r.types.includes('country'));
    if (address) {
        const countryComponent = address.address_components.find(c => c.types.includes('country'));
        if (countryComponent) {
            actualCountryData.name = normalizeCountryName(countryComponent.long_name);
            actualCountryData.code = countryComponent.short_name;
        }
    } else {
        actualCountryData = { name: normalizeCountryName(country.name), code: country.code, bounds: bounds };
    }

    panorama.setOptions({
        pano: data.location.pano,
        pov: { heading: Math.random() * 360, pitch: 0 },
        zoom: 0,
        visible: true,
    });
    document.getElementById('loading-overlay').style.display = 'none';
    gameState.roundActive = true; // Riattiviamo il round per permettere di fare la guess
}
        
        
        function showRoundResult(score, distance, isCountryCorrect, guessedCountryName) {
    mapContainer.classList.add('fullscreen');
    mapContainer.classList.remove('enlarged');
    panorama.setOptions({ linksControl: false, panControl: false });

    document.getElementById('result-score').textContent = `${score} / 5000 points`;
    document.getElementById('result-distance').textContent = `You were ${(distance / 1000).toFixed(1)} km away.`;
    let countryText = `Correct Country: ${actualCountryData.name}.`;
    if (!isCountryCorrect) {
        countryText += ` You guessed: ${guessedCountryName}.`;
    }
    document.getElementById('result-country').textContent = countryText;

    actualMarker = new google.maps.Marker({
        position: actualLocation, map: map,
        icon: { path: google.maps.SymbolPath.CIRCLE, scale: 8, fillColor: "#f43f5e", fillOpacity: 1, strokeColor: "white", strokeWeight: 2 }
    });
    actualMarker.setVisible(true);

    guessLine = new google.maps.Polyline({
        path: [actualLocation, guessMarker.getPosition()], geodesic: true,
        strokeColor: '#ef4444', strokeOpacity: 0.8, strokeWeight: 2
    });
    guessLine.setMap(map);

    const bounds = new google.maps.LatLngBounds();
    bounds.extend(actualLocation);
    bounds.extend(guessMarker.getPosition());
    setTimeout(() => map.fitBounds(bounds, 60), 100);

    document.getElementById('result-overlay').style.display = 'flex';
    submitBtn.classList.remove('hidden'); // Assicuriamoci che il pulsante sia visibile
}
        
        // --- STATISTICS & PANO ID HELPERS ---
        function getGameStats() { return JSON.parse(localStorage.getItem('geoTrainingStats') || '[]'); }
        
        function saveGameStats(newStat) {
            const stats = getGameStats();
            stats.push(newStat);
            localStorage.setItem('geoTrainingStats', JSON.stringify(stats));
        }

        function getUsedPanoIds() {
            const ids = localStorage.getItem('usedPanoIds');
            return ids ? new Set(JSON.parse(ids)) : new Set();
        }

        function addUsedPanoId(panoId) {
            const usedPanoIds = getUsedPanoIds();
            usedPanoIds.add(panoId);
            let idArray = Array.from(usedPanoIds);
            if (idArray.length > 1000) { 
                idArray = idArray.slice(idArray.length - 1000);
            }
            localStorage.setItem('usedPanoIds', JSON.stringify(idArray));
        }

        function showStatsPage() {
            document.getElementById('stats-page').style.display = 'block';
            document.querySelector('.stat-tab[data-tab="core"]').click();
        }

        function renderAllCharts(stats) {
            const activeTab = document.querySelector('.stat-tab.active')?.dataset.tab;
            if (!activeTab) return;

            const container = document.getElementById(activeTab + '-tab');
            const placeholder = document.getElementById('stats-placeholder');
            if (stats.length < 1) {
                document.querySelectorAll('.stat-tab-content').forEach(c => c.style.display = 'none');
                if(placeholder) placeholder.style.display = 'block';
                return;
            } else {
                 document.querySelectorAll('.stat-tab-content').forEach(c => {
                    if(c.id === `${activeTab}-tab`) {
                        c.style.display = 'grid';
                    } else {
                        c.style.display = 'none';
                    }
                 });
                 if(placeholder) placeholder.style.display = 'none';
            }

            Object.values(charts).forEach(chart => { if(chart) chart.destroy(); });
            
            if (activeTab === 'core') {
                renderCorePerformanceMetrics(stats);
                renderPerCountryTable(stats, currentSort.column, currentSort.order);
                 // Modifica la chiamata a renderPerformanceMap in questo modo:
    const activeRegionBtn = document.querySelector('#map-region-controls .map-region-btn.active');
    const currentRegion = activeRegionBtn ? activeRegionBtn.dataset.region : 'world';
    renderPerformanceMap(stats, currentRegion);
            } else if (activeTab === 'confusion') {
                renderConfusionMatrix(stats);
                renderTopConfusions(stats);
            } else if (activeTab === 'improvement') {
                renderAccuracyHistory(stats);
                renderNemesisImprovement(stats);
            } else if (activeTab === 'additional') {
                renderDistanceErrorTrend(stats);
                renderContinentPerformance(stats);
                renderCountryByContinentChart(stats);
            }
        }
        
        // Incolla questa nuova funzione al posto della vecchia renderOverallAccuracy
function renderCorePerformanceMetrics(stats) {
    // Logica per l'accuratezza (invariata)
    const correct = stats.filter(s => normalizeCountryName(s.actualCountry.name) === normalizeCountryName(s.guessedCountry.name)).length;
    const total = stats.length;
    const accuracy = total > 0 ? ((correct / total) * 100).toFixed(1) : 0;
    document.getElementById('overall-accuracy').textContent = `${accuracy}%`;
    document.getElementById('total-games').textContent = `Based on ${total} games played.`;

    // NUOVA Logica per il record della serie
    // Carichiamo il valore più recente dal gameState, che è stato caricato all'avvio
    const longestStreak = gameState.longestStreak || 0; 
    document.getElementById('longest-streak-stat').textContent = longestStreak;
    if(longestStreak > 0){
         document.getElementById('longest-streak-date').textContent = `Your personal best!`;
    } else {
         document.getElementById('longest-streak-date').textContent = `Keep playing to set a record!`;
    }
}
        
        function renderPerCountryTable(stats, sortBy = 'name', order = 'asc') {
             const countryData = stats.reduce((acc, game) => {
                const name = normalizeCountryName(game.actualCountry.name);
                if (!acc[name]) {
                    acc[name] = { name, seen: 0, correct: 0 };
                }
                acc[name].seen++;
                if (normalizeCountryName(game.actualCountry.name) === normalizeCountryName(game.guessedCountry.name)) {
                    acc[name].correct++;
                }
                return acc;
            }, {});
            
            const tableData = Object.values(countryData).map(d => ({
                ...d,
                accuracy: d.seen > 0 ? (d.correct / d.seen) * 100 : 0
            }));
            
            tableData.sort((a,b) => {
                let valA = a[sortBy];
                let valB = b[sortBy];
                if (typeof valA === 'string') {
                    return order === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                return order === 'asc' ? valA - valB : valB - valA;
            });
            
            const tableBody = document.getElementById('country-perf-table');
            tableBody.innerHTML = tableData.map(d => `
                <tr class="hover:bg-gray-50">
                    <td class="p-2 country-link" data-country="${d.name}">${d.name}</td>
                    <td class="p-2">${d.seen}</td>
                    <td class="p-2">${d.correct}</td>
                    <td class="p-2">${d.accuracy.toFixed(1)}%</td>
                </tr>
            `).join('');

            const sortedByAccuracy = [...tableData].sort((a,b) => b.accuracy - a.accuracy);
            const forteList = document.querySelector('#forte-list ul');
            forteList.innerHTML = sortedByAccuracy.slice(0, 5).map(c => `<li class="country-link" data-country="${c.name}">${c.name} (${c.accuracy.toFixed(1)}%)</li>`).join('') || '<li>Play more to find your forte!</li>';
            
            const nemesisList = document.querySelector('#nemesis-list ul');
            nemesisList.innerHTML = sortedByAccuracy.slice(-5).reverse().map(c => `<li class="country-link" data-country="${c.name}">${c.name} (${c.accuracy.toFixed(1)}%)</li>`).join('') || '<li>No nemesis yet!</li>';
            
            document.querySelectorAll('.country-link').forEach(el => {
                el.addEventListener('click', () => showCountryBreakdown(el.dataset.country, stats));
            });
        }
        
        function renderConfusionMatrix(stats) {
            const matrix = {};
            const actualCountries = new Set();
            const guessedCountries = new Set();
            
            stats.forEach(game => {
                const actual = normalizeCountryName(game.actualCountry.name);
                const guessed = normalizeCountryName(game.guessedCountry.name);
                
                actualCountries.add(actual);
                if (guessed !== 'Unknown') {
                     guessedCountries.add(guessed);
                }
                
                if (actual === guessed || guessed === 'Unknown') return;
                
                if (!matrix[actual]) matrix[actual] = {};
                if (!matrix[actual][guessed]) matrix[actual][guessed] = 0;
                
                matrix[actual][guessed]++;
            });

            const sortedActual = [...actualCountries].sort();
            const sortedGuessed = [...guessedCountries].sort();

            const container = document.getElementById('confusion-matrix-container');
            let table = '<table class="min-w-full"><thead><tr><th class="sticky left-0 bg-gray-100 z-10">Actual &#8595; / Guessed &#8594;</th>';
            sortedGuessed.forEach(g => table += `<th>${g}</th>`);
            table += '</tr></thead><tbody>';

            let maxConfusion = 1;
            Object.values(matrix).forEach(row => {
                Object.values(row).forEach(count => {
                    if (count > maxConfusion) maxConfusion = count;
                });
            });

            sortedActual.forEach(actual => {
                table += `<tr><td class="actual-country country-link" data-country="${actual}">${actual}</td>`;
                sortedGuessed.forEach(guessed => {
                    const count = matrix[actual]?.[guessed] || 0;
                    const opacity = count > 0 ? Math.log1p(count) / Math.log1p(maxConfusion) : 0;
                    const color = `rgba(239, 68, 68, ${opacity})`;
                    table += `<td style="background-color: ${color}; color: ${opacity > 0.6 ? 'white' : 'black'}">${count > 0 ? count : ''}</td>`;
                });
                table += '</tr>';
            });

            table += '</tbody></table>';
            container.innerHTML = table;
             document.querySelectorAll('#confusion-matrix-container .country-link').forEach(el => {
                el.addEventListener('click', () => showCountryBreakdown(el.dataset.country, stats));
            });
        }
        
        function renderTopConfusions(stats) {
            const confusions = {};
             stats.forEach(game => {
                const actual = normalizeCountryName(game.actualCountry.name);
                const guessed = normalizeCountryName(game.guessedCountry.name);
                if (actual !== guessed && guessed !== 'Unknown') {
                    const pair = `Confused <strong>${actual}</strong> with <strong>${guessed}</strong>`;
                    confusions[pair] = (confusions[pair] || 0) + 1;
                }
            });
            const sortedConfusions = Object.entries(confusions).sort((a,b) => b[1] - a[1]).slice(0, 10);
            const list = document.getElementById('top-confusions-list');
            list.innerHTML = sortedConfusions.map(([pair, count]) => `<li>${pair}: ${count} times</li>`).join('');
        }
        
        function showCountryBreakdown(country, stats) {
            document.querySelectorAll('.country-name').forEach(el => el.textContent = country);

            const outgoing = {};
            const incoming = {};
            
            stats.forEach(game => {
                const actual = normalizeCountryName(game.actualCountry.name);
                const guessed = normalizeCountryName(game.guessedCountry.name);
                
                if (actual === country && guessed !== country) {
                    outgoing[guessed] = (outgoing[guessed] || 0) + 1;
                }
                if (guessed === country && actual !== country) {
                     incoming[actual] = (incoming[actual] || 0) + 1;
                }
            });

            const outgoingList = document.getElementById('outgoing-confusions');
            const sortedOutgoing = Object.entries(outgoing).sort((a,b) => b[1] - a[1]);
            outgoingList.innerHTML = sortedOutgoing.length ? sortedOutgoing.map(([c, count]) => `<li>${c}: ${count} times</li>`).join('') : '<li>No outgoing confusions!</li>';

            const incomingList = document.getElementById('incoming-confusions');
            const sortedIncoming = Object.entries(incoming).sort((a,b) => b[1] - a[1]);
            incomingList.innerHTML = sortedIncoming.length ? sortedIncoming.map(([c, count]) => `<li>${c}: ${count} times</li>`).join('') : '<li>No incoming confusions!</li>';
            
            document.getElementById('country-breakdown-modal').classList.remove('hidden');
        }
        
       function renderAccuracyHistory(stats) {
            if (charts.accuracyHistory) charts.accuracyHistory.destroy();

            const container = document.getElementById('accuracy-time-toggle-container');
            const activeButton = container.querySelector('.active') || container.querySelector('.time-toggle-btn');
            const numGamesToShow = activeButton.dataset.games;
            
            let data = [];
            let labels = [];

            // Vogliamo mostrare il grafico solo se ci sono almeno 20 partite,
            // poiché la media mobile non è significativa prima di allora.
            if(stats.length >= 20) { 
                const filteredStats = numGamesToShow === 'all' ? stats.slice(19) : stats.slice(-parseInt(numGamesToShow));
                const rollingWindow = 50;
                
                for (let i = 0 ; i < filteredStats.length; i++) {
                    // Questo calcola l'indice originale della partita nell'array completo 'stats'.
                    const overallIndex = (numGamesToShow === 'all' ? i + 19 : stats.length - filteredStats.length + i);
                    
                    // --- QUESTA È LA CORREZIONE ---
                    // Saltiamo le prime 19 partite (indici da 0 a 18) perché la loro
                    // media mobile è troppo volatile e non è un buon indicatore di performance.
                    if (overallIndex < 19) {
                        continue;
                    }

                    const window = stats.slice(Math.max(0, overallIndex - rollingWindow + 1), overallIndex + 1);
                    const correct = window.filter(s => normalizeCountryName(s.actualCountry.name) === normalizeCountryName(s.guessedCountry.name)).length;
                    
                    labels.push(`Game ${overallIndex + 1}`);
                    data.push((correct / window.length) * 100);
                }
            }

            const ctx = document.getElementById('accuracy-history-chart').getContext('2d');
            charts.accuracyHistory = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '50-Game Rolling Accuracy %',
                        data: data,
                        borderColor: '#4f46e5',
                        tension: 0.1
                    }]
                },
                options: {
                    scales: {
                        x: { type: 'category' },
                        y: { min: 0, max: 100, title: { display: true, text: 'Accuracy %' } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }
        function renderNemesisImprovement(stats) {
            const container = document.getElementById('nemesis-charts-container');
            container.innerHTML = ''; 
            
            const countryData = stats.reduce((acc, game) => {
                const name = normalizeCountryName(game.actualCountry.name);
                if (!acc[name]) acc[name] = [];
                acc[name].push(game);
                return acc;
            }, {});

            const nemesisCountries = Object.keys(countryData).filter(name => countryData[name].length >= 5).sort();
            
            if (nemesisCountries.length === 0) {
                container.innerHTML = '<p class="text-center col-span-full">Play more games to identify nemesis countries!</p>';
                return;
            }

            nemesisCountries.forEach((countryName, index) => {
                const chartId = `nemesis-chart-${index}`;
                const chartCard = document.createElement('div');
                chartCard.className = 'stat-card';
                chartCard.innerHTML = `<h3>Improvement for ${countryName}</h3><canvas id="${chartId}"></canvas>`;
                container.appendChild(chartCard);
                
                const countryStats = countryData[countryName] || [];
                const rollingWindow = 10;
                const history = [];

                for (let i = 4; i < countryStats.length; i++) {
                     const window = countryStats.slice(Math.max(0, i - rollingWindow + 1), i + 1);
                     const correct = window.filter(s => normalizeCountryName(s.actualCountry.name) === normalizeCountryName(s.guessedCountry.name)).length;
                     history.push({
                         x: new Date(countryStats[i].timestamp),
                         y: (correct / window.length) * 100
                     });
                }
                
                const ctx = document.getElementById(chartId).getContext('2d');
                new Chart(ctx, {
                     type: 'line',
                    data: {
                        datasets: [{
                            label: `${countryName} Accuracy %`,
                            data: history,
                            borderColor: '#d946ef',
                            tension: 0.1
                        }]
                    },
                    options: {
                        scales: {
                            x: { type: 'time', time: { unit: 'day' } },
                            y: { min: 0, max: 100, title: { display: true, text: 'Accuracy %' } }
                        }
                    }
                });
            });
        }
        
        function renderDistanceErrorTrend(stats) {
            if (charts.distanceError) charts.distanceError.destroy();
            const container = document.getElementById('distance-time-toggle-container');
            const activeButton = container.querySelector('.active') || container.querySelector('.time-toggle-btn');
            const numGamesToShow = activeButton.dataset.games;
            
            const filteredStats = numGamesToShow === 'all' ? stats : stats.slice(-parseInt(numGamesToShow));

            const ctx = document.getElementById('distance-error-chart').getContext('2d');
            charts.distanceError = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: filteredStats.map((_, i) => `Game ${stats.length - filteredStats.length + i + 1}`),
                    datasets: [{
                        label: 'Distance Error (km)',
                        data: filteredStats.map(s => s.distance),
                        borderColor: 'rgba(239, 68, 68, 1)',
                        backgroundColor: 'rgba(239, 68, 68, 0.2)',
                        tension: 0.1,
                        fill: true,
                    }]
                },
                options: {
                    scales: { 
                        y: { 
                            type: 'logarithmic',
                            title: { display: true, text: 'Distance (km)' },
                            ticks: {
                                callback: function (value, index, ticks) {
                                    if (value >= 1000 && value % 1000 === 0) return value/1000 + 'k';
                                    if (value >= 100 && value % 100 === 0) return value;
                                    if (value >= 10 && value % 10 === 0) return value;
                                    if (value <= 10 && value > 0) return value;
                                    return null;
                                }
                            }
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }
        
        function renderContinentPerformance(stats) {
            if (charts.continents) charts.continents.destroy();
             const continentData = stats.reduce((acc, game) => {
                const countryInfo = STREET_VIEW_COUNTRIES.find(c => c.code === game.actualCountry.code);
                if (!countryInfo) return acc;
                const continent = countryInfo.continent;
                if (!acc[continent]) {
                    acc[continent] = { totalScore: 0, count: 0 };
                }
                acc[continent].totalScore += game.score;
                acc[continent].count++;
                return acc;
            }, {});

            const labels = Object.keys(continentData);
            const data = labels.map(label => continentData[label].totalScore / continentData[label].count);

            const ctx = document.getElementById('continent-performance-chart').getContext('2d');
            charts.continents = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Average Score',
                        data: data,
                        fill: true,
                        backgroundColor: 'rgba(74, 222, 128, 0.2)',
                        borderColor: 'rgb(74, 222, 128)',
                    }]
                },
                options: {
                    scales: { r: { angleLines: { display: true }, suggestedMin: 0, suggestedMax: 5000 }},
                    plugins: { legend: { display: false } }
                }
            });
        }

        function renderCountryByContinentChart(stats) {
            if (charts.countryByContinent) charts.countryByContinent.destroy();
            const dataByContinent = stats.reduce((acc, game) => {
                const countryInfo = STREET_VIEW_COUNTRIES.find(c => c.name === normalizeCountryName(game.actualCountry.name));
                if (!countryInfo) return acc;
                
                const { continent, name } = countryInfo;
                if (!acc[continent]) acc[continent] = {};
                if (!acc[continent][name]) acc[continent][name] = { totalScore: 0, count: 0 };
                
                acc[continent][name].totalScore += game.score;
                acc[continent][name].count++;
                
                return acc;
            }, {});

            const datasets = [];
            const continentColors = {
                'Europe': 'rgba(59, 130, 246, 0.8)', 'Asia': 'rgba(239, 68, 68, 0.8)',
                'North America': 'rgba(245, 158, 11, 0.8)', 'South America': 'rgba(34, 197, 94, 0.8)',
                'Africa': 'rgba(139, 92, 246, 0.8)', 'Oceania': 'rgba(236, 72, 153, 0.8)'
            };
            
            const allCountryLabels = [...new Set(stats.map(s => normalizeCountryName(s.actualCountry.name)))].sort();
            
            for (const continent of Object.keys(continentColors).sort()) {
                 if (!dataByContinent[continent]) continue;
                 const continentData = dataByContinent[continent];
                 
                 const data = allCountryLabels.map(countryName => {
                    if (continentData[countryName]) {
                        return continentData[countryName].totalScore / continentData[countryName].count;
                    }
                    return null; 
                 });

                 datasets.push({
                    label: continent,
                    data: data,
                    backgroundColor: continentColors[continent],
                    barPercentage: 0.8,
                    categoryPercentage: 0.8
                 });
            }

            const ctx = document.getElementById('country-by-continent-chart').getContext('2d');
            charts.countryByContinent = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: allCountryLabels,
                    datasets: datasets
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { min: 0, max: 5000, stacked: true, title: { display: true, text: 'Average Score' }},
                        y: { stacked: true, ticks: { font: { size: 12 } } }
                    },
                    plugins: {
                        legend: { position: 'top' }
                    }
                }
            });
        }
        
        function triggerCelebration(isSuper) {
            playVictorySound(isSuper);
            const canvas = document.getElementById('fireworks-canvas');
            canvas.style.display = 'block';
            const ctx = canvas.getContext('2d');
            const fireworks = [];
            let animationFrameId;

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            function createFirework() {
                const x = Math.random() * canvas.width;
                const y = canvas.height;
                const targetY = Math.random() * (canvas.height / 2);
                const color = `hsl(${Math.random() * 360}, 100%, 70%)`;
                fireworks.push({ x, y, targetY, color, particles: [] });
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                let spawnRate = isSuper ? 0.1 : 0.05;
                if (Math.random() < spawnRate && fireworks.length < (isSuper ? 10 : 5)) {
                    createFirework();
                }

                for (let i = fireworks.length - 1; i >= 0; i--) {
                    const fw = fireworks[i];
                    if (!fw.exploded) {
                        ctx.beginPath();
                        ctx.fillStyle = fw.color;
                        ctx.arc(fw.x, fw.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        fw.y -= 4; 
                        if (fw.y < fw.targetY) {
                            fw.exploded = true;
                            explode(fw, isSuper);
                        }
                    } else {
                        updateParticles(fw);
                        if(fw.particles.length === 0) {
                            fireworks.splice(i, 1);
                        }
                    }
                }
                
                animationFrameId = requestAnimationFrame(animate);
            }

            function explode(firework, isSuper) {
                const particleCount = isSuper ? 120 : 70;
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * (isSuper ? 6 : 4) + 1;
                    firework.particles.push({
                        x: firework.x, y: firework.y,
                        vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                        color: firework.color, size: Math.random() * 2 + 1, alpha: 1
                    });
                }
            }

            function updateParticles(firework) {
                 for (let i = firework.particles.length - 1; i >= 0; i--) {
                    const p = firework.particles[i];
                    ctx.save();
                    ctx.globalAlpha = p.alpha;
                    ctx.beginPath();
                    ctx.fillStyle = p.color;
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.03; 
                    p.alpha -= 0.015;
                    if (p.alpha <= 0) firework.particles.splice(i, 1);
                }
            }
            
            animate();
            setTimeout(() => { 
                canvas.style.display = 'none';
                cancelAnimationFrame(animationFrameId);
            }, isSuper ? 8000 : 5000);
        }

       // --- LOAD GOOGLE MAPS SCRIPT (MODO SICURO) ---
document.addEventListener('DOMContentLoaded', function() {
    // Questo codice viene eseguito solo dopo che l'intera pagina HTML è pronta.
    console.log("DOM completamente caricato. Avvio l'inizializzazione della mappa.");

    const script = document.createElement('script');
    // CORREZIONE: Usa il nome corretto della costante.
    script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&callback=initMap&libraries=geometry`;
    script.async = true;
    script.defer = true;
    document.head.appendChild(script);
});
        
    </script>
</body>
</html>
