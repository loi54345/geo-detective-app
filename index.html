async function findRandomStreetViewLocation() {
    let randomCountry;

    // --- INIZIO NUOVA LOGICA DI SELEZIONE ---
    if (activeGameMode === 'World') {
        const countriesToSearch = STREET_VIEW_COUNTRIES;
        randomCountry = countriesToSearch[Math.floor(Math.random() * countriesToSearch.length)];
    } else if (activeGameMode === 'WeightedWorld') {
        const countriesToSearch = STREET_VIEW_COUNTRIES;
        const totalArea = countriesToSearch.reduce((sum, country) => sum + (country.area || 0), 0);
        let randomWeight = Math.random() * totalArea;
        for (const country of countriesToSearch) {
            randomWeight -= (country.area || 0);
            if (randomWeight <= 0) {
                randomCountry = country;
                break;
            }
        }
    } else if (activeGameMode === 'Nemesis') {
        // NUOVA MODALITA': Allenamento Nemesis
        console.log("Modalità Nemesis attivata. Calcolo i paesi peggiori...");
        const nemesisCountries = getNemesisCountries();

        if (nemesisCountries.length === 0) {
            console.log("Nessun paese 'Nemesis' trovato (serve più storico). Avvio una partita 'World' normale.");
            alert("Non hai ancora abbastanza dati per la modalità Nemesis! Verrà avviato un round 'Mondo'. Gioca di più per sbloccarla!");
            // Se non ci sono dati, giochiamo una partita "World" normale
            const countriesToSearch = STREET_VIEW_COUNTRIES;
            randomCountry = countriesToSearch[Math.floor(Math.random() * countriesToSearch.length)];
        } else {
            console.log("Paesi Nemesis trovati:", nemesisCountries.map(c => c.name));
            // Scegliamo a caso uno dei paesi nemesis
            randomCountry = nemesisCountries[Math.floor(Math.random() * nemesisCountries.length)];
        }
    } else {
        // Selezione per continente
        const countriesToSearch = STREET_VIEW_COUNTRIES.filter(c => c.continent === activeGameMode);
        if (!countriesToSearch || countriesToSearch.length === 0) {
            alert("Nessun paese disponibile per la modalità di gioco selezionata!");
            return;
        }
        randomCountry = countriesToSearch[Math.floor(Math.random() * countriesToSearch.length)];
    }
    // --- FINE NUOVA LOGICA DI SELEZIONE ---

    // Il resto della funzione rimane invariato
    const countryCode = randomCountry.code;
    const countryName = randomCountry.name;
    const bucketBaseUrl = 'https://storage.googleapis.com/geo-detective-data-tuonome-123';
    const boundariesUrl = `${bucketBaseUrl}/${countryCode}.json`;

    console.log(`Modalità: ${activeGameMode}. Paese scelto: ${countryName}. Recupero confini da: ${boundariesUrl}`);
    document.getElementById('loading-overlay').style.display = 'flex';

    try {
        const response = await fetch(boundariesUrl);
        if (!response.ok) throw new Error(`File non trovato per ${countryName} (${countryCode}.json).`);

        const countryGeoJSON = await response.json();
        if (!countryGeoJSON || !countryGeoJSON.features || countryGeoJSON.features.length === 0) throw new Error(`Dati GeoJSON non validi o vuoti per ${countryName}.`);

        const countryFeature = countryGeoJSON.features.find(f => f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));
        if (!countryFeature) throw new Error(`Nessuna geometria di tipo Polygon o MultiPolygon trovata per ${countryName}.`);

        console.log("Confini caricati e validati. Inizio ricerca punto valido...");
        let randomLatLng;
        let pointFound = false;
        const bbox = turf.bbox(countryFeature.geometry);
        let findPointAttempts = 0;
        while (!pointFound && findPointAttempts < 500) {
            const randomPtArray = turf.randomPosition(bbox); 
            if (turf.booleanPointInPolygon(randomPtArray, countryFeature.geometry)) {
                randomLatLng = new google.maps.LatLng(randomPtArray[1], randomPtArray[0]);
                pointFound = true;
            }
            findPointAttempts++;
        }

        if (!pointFound) throw new Error(`Impossibile trovare un punto valido nei confini di ${countryName} dopo ${findPointAttempts} tentativi.`);

        console.log("Punto valido trovato all'interno dei confini!");
        let panoramaFound = false;
        let panoramaAttempt = 0;
        while(!panoramaFound && panoramaAttempt < 5) {
             console.log(`Ricerca Street View per ${countryName}, tentativo ${panoramaAttempt + 1}...`);
             const { data } = await streetViewService.getPanorama({
                location: randomLatLng,
                radius: 50000 + (panoramaAttempt * 50000),
                source: 'outdoor'
             });
             if (data?.location?.pano) {
                console.log("Panorama trovato!");
                await setupAndFinalizeRound(data, randomCountry, null);
                panoramaFound = true;
                return; 
             }
             panoramaAttempt++;
        }
        throw new Error(`Nessun panorama trovato vicino al punto generato per ${countryName}.`);
    } catch (error) {
        console.error("ERRORE GESTITO:", error.message, "Riprovo con un nuovo paese.");
        startNewRound();
    }
}
